function polinom_newton = poly_newton_with_chebishev(n, left_board, right_board) % принимает количество узлов, левую и правую границу отрезка интерполирования
x = T(n, left_board, right_board); % нашли узлы интерполяции по Чебышеву
f = (cos(x)).^2 + x - 1; % нашли значения в выбранных узлах, функцию оставили прежней
polinom_newton = poly_newton(x, f); % найдем полином Ньютона
% дичь с погрешностью сотворим прямо тут
% выберем рандомную точку point, не совпадающую с узлами интерполяции
% посему возьмем эту точку между парой соседних узлов, шоб уж точно не
% совпало
point = (x(1) + x(2)) / 2; % ну уж не проверяем, что нам ввели хотя бы 2 узла, полагаем, что оно так

M_5 = 16; % max на [0, 10] для 5 производной
M_12 = 2048; % max на [0, 10] для 12 производной

% выведем теоретическую погрешность пользователю:
if (n == 5)
    r_n_max = (M_5*(right_board - left_board)^n / factorial(5)) / 2^(2*n-1) % максимальная теор. погрешность на отрезке [0 10] для 5 точек
else % тогда n = 12, для других случаев не предусмотрено
    r_n_max = (M_12*(right_board - left_board)^n / factorial(12)) / 2^(2*n-1) % максимальная тоер. погрешность на отрезке [0 10] для 12 точек
end
real_pogreshnost_newton_with_chebishev_in_point = abs(((cos(point))^2 + point - 1) - polyval(polinom_newton, point)) 
polifited = polyfit(x, f, n-1)
h = 0:0.001:10; % задали малый шаг для построения
f_n = polyval(polinom_newton, h);% нашли массив значений полинома Ньютона в узлах
ezplot('(cos(x))^2 + x - 1', [0 10]) % рисует реальную функцию, синяя линия
hold on; % остаемся на том же графике
plot(h, f_n, '-m'), grid; % рисует полином ньютона, сиренивые линии
axis tight; % подгоняет границы осей под крайние значения функций
end